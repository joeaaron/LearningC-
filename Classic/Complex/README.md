一般匹配字符串时，我们从目标字符串str（假设长度为n）的第一个下标选取和ptr长度（长度为m）一样的子字符串进行比较，如果一样，就返回开始处的下标值，不一样，选取str下一个下标，同样选取长度为n的字符串进行比较，直到str的末尾（实际比较时，下标移动到n-m）。**这样的时间复杂度是O(n\*m)**。

**KMP算法：可以实现复杂度为O(m+n)**

为何简化了时间复杂度： 
**充分利用了目标字符串ptr的性质（比如里面部分字符串的重复性，即使不存在重复字段，在比较时，实现最大的移动量）。**

**参考文献：**

【1】[字符串匹配KMP算法的讲解C++](https://www.cnblogs.com/lijingran/p/8619711.html)

【2】[字符串匹配的KMP算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

